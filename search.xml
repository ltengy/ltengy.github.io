<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于自定义标签库找不到路径的解决办法]]></title>
    <url>%2F2018%2F08%2F07%2F%E5%85%B3%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%E5%BA%93%E6%89%BE%E4%B8%8D%E5%88%B0%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言最近在学习怎么使用servlet进行自定义标签库的使用，发现一个问题，当我按照书上的代码复现时，死活都找不到标签库。进过分析查找资料，终于解决了这个棘手的问题。 问题说明死活查找不到自己的自定义标签库，错误代码500。网上很多人都遇到过这个毛病，有人说添加xml可以解决，有人说换个路径可以解决，经过尝试，终于解决我的这个棘手问题。 解决办法添加xml1234&lt;taglib&gt; &lt;taglib-uri&gt;mytags&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/jsp/mytaglib.tld&lt;/taglib-location&gt;&lt;/taglib&gt; 经尝试，无法解决我的错误 去掉斜杠 去掉/WEB-INF/前面的斜杠/，也不太管用。 将双引号改为单引号 将双引号改为单引号，重启myesclipse，解决问题。]]></content>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
        <tag>自定义标签库</tag>
        <tag>路径错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于spfk主题的自动摘要]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%9F%BA%E4%BA%8Espfk%E4%B8%BB%E9%A2%98%E7%9A%84%E8%87%AA%E5%8A%A8%E6%91%98%E8%A6%81%2F</url>
    <content type="text"><![CDATA[前言最近又开始捣鼓我的博客，发现我的博客首页一进去就是个空白，对比spfk制作的博客，我陷入了沉思。是不是我的配置错误，还是说我漏了什么文件没有clone。不断的F12调试，重新clone，查找资料，发现原来不是配置的锅，也不是文件缺少，而是没有打上这句话.1&lt;!-- more --&gt; 我赶快把所有的md文件都在合理的位置上打上标记，但是对于一个coder，能不手动就不手动，于是又开始查找相关资料，开始搞事。 自动摘要的原理很多自动摘要的原理都很简单，比如说多少个字符截断，像next主题就是这么干的，但是，那也太难受了，遇到了有代码的，分段的，基本上就成智障了，还得操心。 移植代码参考这位老哥的想法https://blog.zthxxx.me/posts/Hexo-Automatic-Add-ReadMore感觉挺好的，于是动手移植了下代码，不过每个主题的配置都略有不同，所以移植也需要一点点编程知识。先配置_config.yml，在文末增加如下代码1234auto_excerpt: enable: true lines: 1#自定义自动摘要几行 找到themes\hexo-theme-spfk\layout_partial 文件下的article.ejs，用文本编辑器打开，将1&lt;div class="article-entry" itemprop="articleBody"&gt;到&lt;% if (!index &amp;&amp; post.toc != false &amp;&amp; !is_page())&#123; %&gt; 之间的内容替换掉,就可以实现自动readmore了。代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;div class="article-entry" itemprop="articleBody"&gt; &lt;% var show_all_content = true %&gt; &lt;% if (index) &#123; %&gt; &lt;% if (post.excerpt) &#123; %&gt; &lt;% show_all_content = false %&gt; &lt;p&gt;&lt;%- post.excerpt %&gt;&lt;/p&gt; &lt;% &#125; else if (theme.auto_excerpt.enable) &#123; %&gt; &lt;% var br_position = 0 %&gt; &lt;% for (var br_count = 0; br_count &lt; theme.auto_excerpt.lines; br_count++) &#123; %&gt; &lt;% br_position = post.content.indexOf('\n',br_position + 1) %&gt; &lt;% if(br_position &lt; 0) &#123; break &#125; %&gt; &lt;% &#125; %&gt; &lt;% if(br_position &gt; 0) &#123; %&gt; &lt;% show_all_content = false %&gt; &lt;p&gt;&lt;%- post.content.substring(0, br_position + 1) %&gt;&lt;p&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;% &#125; else &#123; %&gt; &lt;% if (post.toc) &#123; %&gt; &lt;div id="toc" class="toc-article"&gt; &lt;strong class="toc-title"&gt;&lt;%= __('article.catalogue') %&gt;&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;% if (show_all_content) &#123; %&gt; &lt;%- post.content %&gt; &lt;% &#125; %&gt; &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.toc)) &amp;&amp; !index)&#123; %&gt; &lt;div class="page-reward"&gt; &lt;p&gt;&lt;a href="javascript:void(0)" onclick="dashangToggle()" class="dashang"&gt;赏&lt;/a&gt;&lt;/p&gt; &lt;div class="hide_box"&gt;&lt;/div&gt; &lt;div class="shang_box"&gt; &lt;a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()"&gt;×&lt;/a&gt; &lt;div class="shang_tit"&gt; &lt;p&gt;&lt;%= theme.reward_wording1%&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="shang_payimg"&gt; &lt;img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" /&gt; &lt;/div&gt; &lt;div class="pay_explain"&gt;&lt;%= theme.reward_wording2%&gt;&lt;/div&gt; &lt;div class="shang_payselect"&gt; &lt;% if(theme.alipay) &#123;%&gt; &lt;div class="pay_item checked" data-id="alipay"&gt; &lt;span class="radiobox"&gt;&lt;/span&gt; &lt;span class="pay_logo"&gt;&lt;img src="&lt;%= theme.alipay%&gt;" alt="支付宝" /&gt;&lt;/span&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% if(theme.weixin) &#123;%&gt; &lt;div class="pay_item" data-id="wechat"&gt; &lt;span class="radiobox"&gt;&lt;/span&gt; &lt;span class="pay_logo"&gt;&lt;img src="&lt;%= theme.weixin%&gt;" alt="微信" /&gt;&lt;/span&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class="shang_info"&gt; &lt;p&gt;打开&lt;span id="shang_pay_txt"&gt;支付宝&lt;/span&gt;扫一扫，即可进行扫码打赏哦&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(".pay_item").click(function()&#123; $(this).addClass('checked').siblings('.pay_item').removeClass('checked'); var dataid=$(this).attr('data-id'); $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg"); $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信"); &#125;); function dashangToggle()&#123; $(".hide_box").fadeToggle(); $(".shang_box").fadeToggle(); &#125; &lt;/script&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;% if (index)&#123; %&gt; &lt;div class="article-info article-info-index"&gt; &lt;%if(post.top)&#123;%&gt; &lt;div class="article-pop-out tagcloud"&gt; &lt;a class=""&gt;置顶&lt;/a&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;%- partial('post/category') %&gt; &lt;%- partial('post/tag') %&gt; &lt;% if (index &amp;&amp; (post.description || post.excerpt ||!show_all_content))&#123; %&gt; &lt;p class="article-more-link"&gt; &lt;a &lt;% if (!theme.excerpt_link)&#123; %&gt;class="hidden"&lt;% &#125; %&gt; href="&lt;%- url_for(post.path) %&gt;#more"&gt;&lt;%= theme.excerpt_link %&gt; &gt;&gt;&lt;/a&gt; &lt;/p&gt; &lt;% &#125; %&gt; &lt;div class="clearfix"&gt;&lt;/div&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;% if (!index)&#123; %&gt; &lt;%- partial('post/nav') %&gt; &lt;% &#125; %&gt;&lt;/article&gt; 效果效果如图所示 问题自动摘要的行数是对应正文而不包括标题，所以当行数大于一时容易出问题。有时间我准备写一个小标题的摘要配置，先留坑吧 文档下载我把我修改的配置文件传上来，供大家使用点击下载]]></content>
      <tags>
        <tag>spfk</tag>
        <tag>ReadMore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实现验证码demo]]></title>
    <url>%2F2018%2F08%2F04%2F%E9%AA%8C%E8%AF%81%E7%A0%81demo%2F</url>
    <content type="text"><![CDATA[最近要做一个网站，要求实现验证码程序，经过不断调试，终于成功实现功能。 一：验证码生成类生成验证码的话需要用到java的Graphics类库，画出一个验证码废话不多说，直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package verificationCode;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.awt.image.RenderedImage;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.util.HashMap;import java.util.Map;import java.util.Random;import javax.imageio.ImageIO;public class generateCode &#123; private static int width = 150;// 定义图片的width private static int height = 48;// 定义图片的height private static int codeCount = 4;// 定义图片上显示验证码的个数 private static int xx = 25; private static int fontHeight = 42; private static int codeY = 42; private static char[] codeSequence = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' &#125;; /** * 生成一个map集合 * code为生成的验证码 * codePic为生成的验证码BufferedImage对象 * @return */ public static Map&lt;String,Object&gt; generateCodeAndPic() &#123; // 定义图像buffer BufferedImage buffImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); // Graphics2D gd = buffImg.createGraphics(); // Graphics2D gd = (Graphics2D) buffImg.getGraphics(); Graphics gd = buffImg.getGraphics(); // 创建一个随机数生成器类 Random random = new Random(); // 将图像填充为白色 gd.setColor(Color.WHITE); gd.fillRect(0, 0, width, height); // 创建字体，字体的大小应该根据图片的高度来定。 Font font = new Font("Fixedsys", Font.BOLD, fontHeight); // 设置字体。 gd.setFont(font); // 画边框。 gd.setColor(Color.BLACK); gd.drawRect(0, 0, width - 1, height - 1); gd.setFont(font); // 随机产生40条干扰线，使图象中的认证码不易被其它程序探测到。 int red = 0, green = 0, blue = 0; // randomCode用于保存随机产生的验证码，以便用户登录后进行验证。 StringBuffer randomCode = new StringBuffer(); // 随机产生codeCount数字的验证码。 for (int i = 0; i &lt; codeCount; i++) &#123; // 得到随机产生的验证码数字。 String code = String.valueOf(codeSequence[random.nextInt(36)]); // 产生随机的颜色分量来构造颜色值，这样输出的每位数字的颜色值都将不同。 red = random.nextInt(255); green = random.nextInt(255); blue = random.nextInt(255); // 用随机产生的颜色将验证码绘制到图像中。 gd.setColor(new Color(red, green, blue)); gd.drawString(code, (i + 1) * xx, codeY); // 将产生的四个随机数组合在一起。 randomCode.append(code); &#125; for (int i = 0; i &lt; 60; i++) &#123; red = random.nextInt(255); green = random.nextInt(255); blue = random.nextInt(255); // 用随机产生的颜色将验证码绘制到图像中。 gd.setColor(new Color(red, green, blue)); int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(50); int yl = random.nextInt(50); gd.drawLine(x, y, x + xl, y + yl); &#125; Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); //存放验证码 map.put("code", randomCode); //存放生成的验证码BufferedImage对象 map.put("codePic", buffImg); return map; &#125; public static void main(String[] args) throws Exception &#123; //创建文件输出流对象 File file = new File("WebRoot/image/"+System.currentTimeMillis()+".jpg"); FileOutputStream out = null; try &#123; if (!file.exists()) &#123; // 先得到文件的上级目录，并创建上级目录，在创建文件 file.getParentFile().mkdir(); file.createNewFile(); &#125; out = new FileOutputStream(file); Map&lt;String,Object&gt; map = generateCode.generateCodeAndPic(); ImageIO.write((RenderedImage) map.get("codePic"), "jpeg", out); System.out.println("验证码的值为："+map.get("code")); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 二：验证码验证类12345678910111213141516171819202122232425262728293031323334353637383940package verificationCode;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@WebServlet("/checkCode")public class checkCode extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String code = request.getParameter("code"); response.setCharacterEncoding("utf-8");//保证格式正确 response.setContentType("text/html"); // 验证验证码 String sessionCode = request.getSession().getAttribute("code").toString(); if (code != null &amp;&amp; !"".equals(code) &amp;&amp; sessionCode != null &amp;&amp; !"".equals(sessionCode)) &#123; if (code.equalsIgnoreCase(sessionCode)) &#123; response.getWriter().println("验证通过！"); &#125; else &#123; response.getWriter().println("验证失败！"); &#125; &#125; else &#123; response.getWriter().println("验证失败！"); &#125; &#125;&#125; 三：验证码传输类用到doget方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package verificationCode;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.awt.image.RenderedImage;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import verificationCode.generateCode;/** * Servlet implementation class CodeServlet */@WebServlet("/getCode")public class CodeServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 调用工具类生成的验证码和验证码图片 Map&lt;String, Object&gt; codeMap = generateCode.generateCodeAndPic(); // 将四位数字的验证码保存到Session中。 HttpSession session = req.getSession(); session.setAttribute("code", codeMap.get("code").toString()); // 禁止图像缓存。 resp.setHeader("Pragma", "no-cache"); resp.setHeader("Cache-Control", "no-cache"); resp.setDateHeader("Expires", 0); resp.setContentType("image/jpeg"); // 将图像输出到Servlet输出流中。 ServletOutputStream sos; try &#123; sos = resp.getOutputStream(); ImageIO.write((RenderedImage) codeMap.get("codePic"), "jpeg", sos); sos.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 四：jsp验证demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;验证码页面&lt;/title&gt;&lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/js/jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/checkCode" method="post"&gt; 请输入验证码：&lt;input type="text" name="code" style="width: 80px;" /&gt; &lt;div id=random&gt; &lt;img id="imgObj" alt="验证码" src="$&#123;pageContext.request.contextPath&#125;/getCode"&gt; &lt;/div&gt;&lt;button id="b01" type="button"&gt;改变内容&lt;/button&gt;&lt;br/&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; $(function() &#123; //response.getWriter().println("验证失败！"); &#125;); $("#b01").click( function changeImg() &#123; $("#random").html("&lt;img id='imgObj' alt='验证码' src='$&#123;pageContext.request.contextPath&#125;/getCode'&gt;") var imgSrc = $("#imgObj"); var src = imgSrc.attr("src"); imgSrc.attr("src", chgUrl(src)); &#125;); // 时间戳 // 为了使每次生成图片不一致，即不让浏览器读缓存，所以需要加上时间戳 function chgUrl(url) &#123; var timestamp = (new Date()).valueOf(); url = url.substring(0, 20); if ((url.indexOf("&amp;") &gt;= 0)) &#123; url = url + "×tamp=" + timestamp; &#125; else &#123; url = url + "?timestamp=" + timestamp; &#125; return url; &#125;&lt;/script&gt;&lt;/html&gt; 总结虽然只是一个小小的demo，但是实际上用到了许多知识，比如生成验证码的画图，传输验证码doget，验证验证码的dopost和ajax动态更换验证码，麻雀虽小五脏俱全啊。 参考网址https://www.cnblogs.com/nanyangke-cjz/p/7049281.html]]></content>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ccs811调试指南]]></title>
    <url>%2F2018%2F08%2F04%2Fccs811%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言最近使用CCS811这一款集成环境参数测量芯片，由于CCS811本身的原因，导致调试颇为不顺利。现在已经调试出来，把自己的经验分享给大家。主控芯片stm32f103。 问题一：无法正常读取硬件id及状态这个问题有可能是： 1.进行了某些误操作，导致CCS811芯片本身跑飞，所以怎么复位都不能读取。解决办法是对芯片复位，即INT脚接地2.IIC通讯本身有问题，讲IIC通讯的读和写里的延迟加大，至少5us 问题二：从boot模式转换到测量模式失败当上面的参数能读取出来的时候，其实通讯本身已经没有问题，但是由于CCS811内部集成的MCU需要一定的时间转换模式，即当我们发送测量转换指令后，必须等待至少180us时间，才能够对ccs811进行读写操作，假如提前读写便导致CCS811跑飞。解决办法，当发送转换指令时必须等待180us，代码如下 12345678910111213141516//测量数据前必须开启void app_Start(void)&#123; nWAKE=0; delay_us(50); IIC_Start(); IIC_Send_Byte(WRIT); //发送写命令 if(IIC_Wait_Ack())&#123; IIC_Stop();return;&#125; IIC_Send_Byte(0xF4); delay_us(180); //必须等待180us以上才能够收到应答 if(IIC_Wait_Ack())&#123;IIC_Stop();return;&#125; IIC_Stop(); nWAKE=1;&#125; 问题三：进入测量模式但无法读取环境参数这个问题也是CCS811内部集成的MCU的锅，当进入测量模式后，CCS811的IIC通讯就变慢了，也就是说，IIC通讯必须变慢，否则CCS811反应不过来。解决办法是调整IIC读写速度，读写延迟至少50us。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142//测量数据前必须开启void IIC_Send_Byte(u8 txd)&#123; u8 t; SDA_OUT(); IIC_SCL=0;//拉低时钟开始数据传输 for(t=0;t&lt;8;t++) &#123; if((txd&amp;0x80)&gt;&gt;7) IIC_SDA=1; else IIC_SDA=0; txd&lt;&lt;=1; delay_us(50); //对TEA5767这三个延时都是必须的 IIC_SCL=1; delay_us(50); IIC_SCL=0; delay_us(50); &#125; &#125; //读1个字节，ack=1时，发送ACK，ack=0，发送nACK u8 IIC_Read_Byte(unsigned char ack)&#123; unsigned char i,receive=0; SDA_IN();//SDA设置为输入 for(i=0;i&lt;8;i++ ) &#123; IIC_SCL=0; delay_us(50); IIC_SCL=1; receive&lt;&lt;=1; if(READ_SDA)receive++; delay_us(50); &#125; if (!ack) IIC_NAck();//发送nACK else IIC_Ack(); //发送ACK return receive;&#125; 其他问题按照器件手册上的介绍都可以解决 结束语调试一块板子真的很不容易，尤其是官方文档写的奇奇怪怪的。一开始以为IIC有问题，调了两三天，后面才明白怎么回事，如果有一块逻辑分析仪应该不用这么久吧。附上我写的库，祝大家能够早日调出来。点击下载]]></content>
      <tags>
        <tag>ccs811</tag>
        <tag>stm32</tag>
        <tag>stm32f103</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 45道经典练习]]></title>
    <url>%2F2018%2F06%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言最近学了SQL，但对查询等操作还是不熟练，于是网上找了一套题目自己做，从实际操纵中一点一点学习sql的语句，相信大家耐心做完题后，会和我一样对sql有一个新的领悟 一：准备工作准备建库下面是建库代码12345678910111213141516171819202122CREATE TABLE students(sno VARCHAR(3) NOT NULL, sname VARCHAR(4) NOT NULL,ssex VARCHAR(2) NOT NULL, sbirthday DATETIME,class VARCHAR(5))CREATE TABLE courses(cno VARCHAR(5) NOT NULL, cname VARCHAR(10) NOT NULL, tno VARCHAR(10) NOT NULL)CREATE TABLE scores (sno VARCHAR(3) NOT NULL, cno VARCHAR(5) NOT NULL, degree NUMERIC(10, 1) NOT NULL) CREATE TABLE teachers (tno VARCHAR(3) NOT NULL, tname VARCHAR(4) NOT NULL, tsex VARCHAR(2) NOT NULL, tbirthday DATETIME NOT NULL, prof VARCHAR(6), depart VARCHAR(10) NOT NULL) 插入数据代码1234567891011121314151617181920212223242526272829INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (108 ,'曾华' ,'男' ,'1977-09-01',95033);INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (105 ,'匡明' ,'男' ,'1975-10-02',95031);INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (107 ,'王丽' ,'女' ,'1976-01-23',95033);INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (101 ,'李军' ,'男' ,'1976-02-20',95033);INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (109 ,'王芳' ,'女' ,'1975-02-10',95031);INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (103 ,'陆君' ,'男' ,'1974-06-03',95031);INSERT INTO COURSES(CNO,CNAME,TNO)VALUES ('3-105' ,'计算机导论',825);INSERT INTO COURSES(CNO,CNAME,TNO)VALUES ('3-245' ,'操作系统' ,804);INSERT INTO COURSES(CNO,CNAME,TNO)VALUES ('6-166' ,'数据电路' ,856);INSERT INTO COURSES(CNO,CNAME,TNO)VALUES ('9-888' ,'高等数学' ,100);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (103,'3-245',86);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (105,'3-245',75);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (109,'3-245',68);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (103,'3-105',92);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (105,'3-105',88);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (109,'3-105',76);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (101,'3-105',64);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (107,'3-105',91);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (108,'3-105',78);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (101,'6-166',85);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (107,'6-106',79);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (108,'6-166',81);INSERT INTO TEACHERS(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (804,'李诚','男','1958-12-02','副教授','计算机系');INSERT INTO TEACHERS(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (856,'张旭','男','1969-03-12','讲师','电子工程系');INSERT INTO TEACHERS(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (825,'王萍','女','1972-05-05','助教','计算机系');INSERT INTO TEACHERS(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (831,'刘冰','女','1977-08-14','助教','电子工程系'); 问题:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152531、 查询Student表中的所有记录的Sname、Ssex和Class列。2、 查询教师所有的单位即不重复的Depart列。3、 查询Student表的所有记录。4、 查询Score表中成绩在60到80之间的所有记录。5、 查询Score表中成绩为85，86或88的记录。6、 查询Student表中“95031”班或性别为“女”的同学记录。7、 以Class降序查询Student表的所有记录。8、 以Cno升序、Degree降序查询Score表的所有记录。9、 查询“95031”班的学生人数。10、查询Score表中的最高分的学生学号和课程号。11、查询‘3-105’号课程的平均分。12、查询Score表中至少有5名学生选修的并以3开头的课程的平均分数。13、查询最低分大于70，最高分小于90的Sno列。14、查询所有学生的Sname、Cno和Degree列。15、查询所有学生的Sno、Cname和Degree列。16、查询所有学生的Sname、Cname和Degree列。17、查询“95033”班所选课程的平均分。18、假设使用如下命令建立了一个grade表：create table grade(low number(3,0),upp number(3),rank char(1));insert into grade values(90,100,’A’);insert into grade values(80,89,’B’);insert into grade values(70,79,’C’);insert into grade values(60,69,’D’);insert into grade values(0,59,’E’);commit;现查询所有同学的Sno、Cno和rank列。19、查询选修“3-105”课程的成绩高于“109”号同学成绩的所有同学的记录。20、查询score中选学一门以上课程的同学中分数为非最高分成绩的记录。21、查询成绩高于学号为“109”、课程号为“3-105”的成绩的所有记录。22、查询和学号为108的同学同年出生的所有学生的Sno、Sname和Sbirthday列。23、查询“张旭“教师任课的学生成绩。24、查询选修某课程的同学人数多于5人的教师姓名。25、查询95033班和95031班全体学生的记录。26、查询存在有85分以上成绩的课程Cno.27、查询出“计算机系“教师所教课程的成绩表。28、查询“计算机系”与“电子工程系“不同职称的教师的Tname和Prof。29、查询选修编号为“3-105“课程且成绩至少高于选修编号为“3-245”的同学的Cno、Sno和Degree,并按Degree从高到低次序排序。30、查询选修编号为“3-105”且成绩高于选修编号为“3-245”课程的同学的Cno、Sno和Degree.31、查询所有教师和同学的name、sex和birthday.32、查询所有“女”教师和“女”同学的name、sex和birthday.33、查询成绩比该课程平均成绩低的同学的成绩表。34、查询所有任课教师的Tname和Depart.35 查询所有未讲课的教师的Tname和Depart. 36、查询至少有2名男生的班号。37、查询Student表中不姓“王”的同学记录。38、查询Student表中每个学生的姓名和年龄。39、查询Student表中最大和最小的Sbirthday日期值。40、以班号和年龄从大到小的顺序查询Student表中的全部记录。41、查询“男”教师及其所上的课程。42、查询最高分同学的Sno、Cno和Degree列。43、查询和“李军”同性别的所有同学的Sname.44、查询和“李军”同性别并同班的同学Sname.45、查询所有选修“计算机导论”课程的“男”同学的成绩表 部分参考答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511、 查询Student表中的所有记录的Sname、Ssex和Class列。select Sname,Ssex,Class from students2、 查询教师所有的单位即不重复的Depart列。select distinct Depart from teachers 3、 查询Student表的所有记录。select *from students4、 查询Score表中成绩在60到80之间的所有记录。select *from scores where degree&gt;=60 and degree&lt;=805、 查询Score表中成绩为85，86或88的记录。select *from scores where degree=85 or degree=86 or degree=886、 查询Student表中“95031”班或性别为“女”的同学记录。select *from students where class='95031' or ssex='女'7、 以Class降序查询Student表的所有记录。select *from students order by class desc8、 以Cno升序、Degree降序查询Score表的所有记录。select *from scores order by cno asc, degree desc9、 查询“95031”班的学生人数。select count(distinct sno) from students where class='95031'10、查询Score表中的最高分的学生学号和课程号。select sno,cno from scores where degree=(select max(degree) from scores)11、查询'3-105'号课程的平均分。select avg(degree) from scores where cno='3-105'12、查询Score表中至少有5名学生选修的并以3开头的课程的平均分数。select avg(degree) from scores where cno= (select cno from scores group by cno having cno like '3%' and count(*)&gt;5 )13、查询最低分大于70，最高分小于90的Sno列。select sno from scores group by sno having min(degree) &gt;70 and max(degree) &lt;9014、查询所有学生的Sname、Cno和Degree列。select sname,cno,degree from students ,scoreswhere students.sno=scores.sno15、查询所有学生的Sno、Cname和Degree列。select students.sno,cname,degree from students ,courses,scoreswhere students.sno=scores.sno and scores.cno=courses.cno16、查询所有学生的Sname、Cname和Degree列。select Sname,cname,degree from students ,courses,scoreswhere students.sno=scores.sno and scores.cno=courses.cno17、查询“95033”班所选课程的平均分。select avg(degree) from scores where sno in (select sno from students where class='95033')18、假设使用如下命令建立了一个grade表：create table grade(low float(3),upp float(3), rank char(1));insert into grade values(90,100,'A');insert into grade values(80,89,'B');insert into grade values(70,79,'C');insert into grade values(60,69,'D');insert into grade values(0,59,'E');commit;现查询所有同学的Sno、Cno和rank列。select sno,cno,grade.rank from scores,gradewhere degree between low and upp 19、查询选修“3-105”课程的成绩高于“109”号同学成绩的所有同学的记录。select *from students where sno in(select sno from scores where cno='3-105' and degree&gt;(select scores.degree from scores where sno='109' and cno='3-105'))20、查询score中选学一门以上课程的同学中分数为非最高分成绩的记录。select * from scores a where a.degree != (select MAX(degree) from scores b group by sno having COUNT (b.cno)&gt;1 and a.sno=b.sno)select * from scores order by sno 21、查询成绩高于学号为“109”、课程号为“3-105”的成绩的所有记录。select * from scores where cno='3-105' and degree&gt;(select scores.degree from scores where sno='109' and cno='3-105')22、查询和学号为108的同学同年出生的所有学生的Sno、Sname和Sbirthday列。SELECT s1.Sno,s1.Sname,s1.SbirthdayFROM Students AS s1 INNER JOIN Students AS s2ON(YEAR(s1.Sbirthday)=YEAR(s2.Sbirthday))WHERE s2.Sno='108';23、查询“张旭“教师任课的学生成绩。select sno,degree from scores where cno = (select cno from courses where tno =(select tno from teachers where tname='张旭'))24、查询选修某课程的同学人数多于5人的教师姓名。select tname from teachers where tno=(select tno from courses where cno =(select cno from scores group by cno having COUNT(sno)&gt;5))25、查询95033班和95031班全体学生的记录。select * from students where class='95033' or class='95031' order by class desc26、查询存在有85分以上成绩的课程Cno.select cno from scores group by cno having MAX(degree)&gt;8527、查询出“计算机系“教师所教课程的成绩表。select * from scores ,teachers,courses where depart='计算机系' and courses.tno=teachers.tno andscores.cno=courses.cno28、查询“计算机系”与“电子工程系“不同职称的教师的Tname和Prof。select tname,prof from teachers where depart='计算机系' or depart='电子工程系'29、查询选修编号为“3-105“课程且成绩至少高于选修编号为“3-245”的同学的Cno、Sno和Degree,并按Degree从高到低次序排序。select * from scores a where cno='3-105' and sno in(select sno from scores b where cno='3-245' and a.degree&gt;b.degree) order by degree desc30、查询选修编号为“3-105”且成绩高于选修编号为“3-245”课程的同学的Cno、Sno和Degree.31、查询所有教师和同学的name、sex和birthday.select tname as name ,tsex as sex ,tbirthday as birthday from teachers unionselect sname as name ,ssex as sex ,sbirthday as birthday from students32、查询所有“女”教师和“女”同学的name、sex和birthday.select tname as name ,tsex as sex ,tbirthday as birthday from teachers where tsex='女'unionselect sname as name ,ssex as sex ,sbirthday as birthday from students where ssex='女'33、查询成绩比该课程平均成绩低的同学的成绩表。select *from scores a where a.degree &lt;(select AVG(degree) from scores b group by cno having b.cno=a.cno) select AVG(degree)as avg,cno from scores group by cno34、查询所有任课教师的Tname和Depart.select tname,depart from teachers where tno in(select tno from courses)35 查询所有未讲课的教师的Tname和Depart. select tname,depart from teachers where tno not in(select tno from courses)36、查询至少有2名男生的班号。select class from students group by class having COUNT(ssex)&gt;137、查询Student表中不姓“王”的同学记录。select *from students where sname not like '王_'38、查询Student表中每个学生的姓名和年龄。39、查询Student表中最大和最小的Sbirthday日期值。select MAX(sbirthday),MIN(sbirthday) from students 40、以班号和年龄从大到小的顺序查询Student表中的全部记录。select * from students order by class desc ,sbirthday 41、查询“男”教师及其所上的课程。select * from courses,teachers where tsex='男' and teachers.tno=courses.tno42、查询最高分同学的Sno、Cno和Degree列。select * from scores a where a.degree=(select MAX(b.degree) from scores b group by b.cno having a.cno=b.cno)43、查询和“李军”同性别的所有同学的Sname.select sname from students where sname!='李军' and ssex=(select ssex from students where sname='李军')44、查询和“李军”同性别并同班的同学Sname.select a.sname from students a,students b where b.sname='李军' and a.ssex=b.ssex and a.class=b.class45、查询所有选修“计算机导论”课程的“男”同学的成绩表select scores.* from scores,courses,students where cname='计算机导论'and courses.cno=scores.cno and scores.sno =students.sno and students.ssex='男' 参考网址https://blog.csdn.net/mrbcy/article/details/68965271]]></content>
      <tags>
        <tag>github</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在windows使用github创建自己的博客]]></title>
    <url>%2F2018%2F06%2F01%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[目前貌似还没有桌面github的教程，我把我的经验拿出来和大家分享 准备工作 github账号 githubdesk hexo github账号 去github注册账号 直接点击signup 在接下来的页面中创建用户名，填写 email 和设定密码，点击「Create an account」按钮创建账户 选择免费版本 githubdesk创建车库项目 githubdesk下载适合自己版本的，安装打开，登录账号 点击左上角File–&gt;creat a new repository 名字填注册名字，本地地址选择桌面 选择自己的车库，添加概要和描述，以master身份确认，最后点击上传这个时候应该可以从浏览器里登陆https://改成自己的名字.github.io/看到一个空白界面，此时第二步也成功了 hexo安装与使用 安装的话直接看hexo 安装成功后开始菜单里打开Node.js command prompt，进入刚刚创建的文件夹，运行cd命令和dir命令 12345cd desktop hexo init blogcd bolghexo g hexo s 这个时候浏览器输入http://localhost:4000/ 可以看到一个网站博客 在blog里面找到文件夹public,把里面的东西都复制到车库里，然后安装之前的步骤上传就可以了。不过网速会很慢]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>githubdesk</tag>
      </tags>
  </entry>
</search>
