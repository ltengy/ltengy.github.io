<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用python进行图像角点探测]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E8%BD%AE%E5%BB%93%E8%A7%92%E7%82%B9%E6%8E%A2%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[前言上次我们发现，只要找到了矩形的四个角点，进行旋转变换后就能够很完美的得到一个横平竖直的矩形。那如何得到四个角点呢？现在比较常见的方式是通过canny算子去探测角点，但是由于角点众多，其实canny算子并不适合表格类型的角点探测。还有一种是通过hough圆变换得到所有直线，然后计算最外围轮廓直线的交点得到角点，但同样的，也因为表格类型的直线较多，且容易在二值化的时候丢失线段，所以处理效果也比较差。这里介绍另外一种方式去探测角点，先确定最大轮廓，然后在这个轮廓里寻找四个角点。 一、轮廓探测轮廓探测比较轻松，opencv里有现成的函数cv2.findContours()，但是要注意输入图像只能二值图像。所以我们需要一定的预处理。下面是我预处理和轮廓探测的代码：1234567gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 彩色图像转为灰度图像 highthreshold,banary_img= cv2.threshold(gray_img, 0, 255, cv2.THRESH_BINARY|cv2.THRESH_OTSU ) # 利用自适应阀值转化为二值图像# 参数参考http://blog.csdn.net/on2way/article/details/46812121 #cv2.findContours() contours = cv2.findContours(banary_img,cv2.RETR_LIST,cv2.CHAIN_APPROX_TC89_L1) #将探测到的所有轮廓赋值给contours，方法是不压缩轮廓点，方便下面寻找 二、角点探测角点探测比较麻烦，通过几篇论文和一位大佬的blog，我使用了尖锐度检测的方式求得角点。原理通俗一点就是通过相邻几个点构成的向量计算其半角正弦值，结合近似原则进行近似计算。下面是我的实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# =============================================================================# 点类# =============================================================================class Point: def __init__(self, point): # x1, y1, x2, y2 = l # 前两个数为起点，后两个数为终点 self.x = point[0] self.y = point[1] def copy(self): return self def toList(self): #将点类转化为list类型 return [int (self.x),int(self.y)] def lenth(self): return 1.*(self.x*self.x+self.y*self.y)**0.5 def measureAngle(self,lastPoint,nextPoint): #计算尖锐度，参考 https://www.cnblogs.com/jsxyhelu/p/5106760.html vect1=[self.x-lastPoint.x,self.y-lastPoint.y] vect2=[self.x-nextPoint.x,self.y-nextPoint.y] vect3=[lastPoint.x-nextPoint.x,lastPoint.y-nextPoint.y] sin=1.0*Point(vect3).lenth()/(Point(vect1).lenth()+Point(vect2).lenth()) return 1-sin def printf(self): print((self.x,self.y)) # =============================================================================# 轮廓类# =============================================================================class Contour(Point): def __init__(self,contour): self.contour=[] for p in contour: self.contour.append(Point(p[0])) self.length=len(contour) def pickLeftPoint(self,currentLocation,setp): #防止取左边相邻点时越界 if currentLocation-setp&lt;0: #print(currentLocation-setp+self.length) return currentLocation-setp+self.length else: #print(currentLocation-setp) return currentLocation-setp def pickRightPoint(self,currentLocation,setp): #防止取右边相邻点时越界 if currentLocation+setp&gt;self.length-1: #print(currentLocation+setp-self.length+1) return currentLocation+setp-self.length+1 else: #print(currentLocation+setp) return currentLocation+setp def getAngle(self,p,setp): #print(p) return self.contour[p].measureAngle(self.contour[self.pickRightPoint(p,setp)], self.contour[self.pickLeftPoint(p,setp)]) def sortPoint(rowdata): x=0 y=0 for p in rowdata: x=p.x+x y=p.y+y x=x/4 y=y/4 sorteddata=[[0,0]]*4 for p in rowdata: if p.x&lt;x and p.y&lt;y: sorteddata[0]=p.toList() if p.x&gt;x and p.y&lt;y: sorteddata[1]=p.toList() if p.x&gt;x and p.y&gt;y: sorteddata[2]=p.toList() if p.x&lt;x and p.y&gt;y: sorteddata[3]=p.toList() return sorteddata def getPoint(contours): index=0 contour = contours[1] j=0 size=0 for i in contour: if i.size&gt;size: size=i.size index=j j=j+1 maxContour=Contour(contour[index]) data=[] datas=[] for p in range(0,maxContour.length-1): y=maxContour.getAngle(p,5) datas.append(y) if 0.1 &lt; y : data.append(maxContour.contour[p]) plt.plot(datas) plt.show() if __name__ == '__main__': old_img = cv2.imread('1.jpg') t_points = img_process(old_img) 三、效果展示由效果来看，程序很好的识别出四个角点，这个时候我们就探测出了该轮廓的四个顶点。]]></content>
      <tags>
        <tag>python</tag>
        <tag>角点探测</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql django 配置问题]]></title>
    <url>%2F2019%2F01%2F27%2Fmysql-django-%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天在配置django+mysql时碰到一个诡异的问题，就是无法连接上mysql报错12345678910django.db.utils.OperationalError: (2006, &lt;NULL&gt;)或者django.db.utils.OperationalError: (2059, "Authentication plugin 'b'sha256_password'' not configured")或者django.db.utils.InternalError: (1862, 'Your password has expired. To log in youmust change it using a client that supports expired passwords.')或者django.db.utils.OperationalError: (1045, "Access denied for user 'cyd'@'localhost' (using password: YES)") 其他配置都正确的情况下，只要改变密码编码方式就好了，可以用navicat for mysql 选择用户插件为mysql_native_password就行了如果遇到12django.db.utils.OperationalError: (1045, "Access denied for user 'cyd'@'localhost' (using password: NO)") 改完密码编码后重启终端再连接即可]]></content>
      <tags>
        <tag>python3</tag>
        <tag>mysql</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python进行纸质文档识别（一）图像旋转矫正]]></title>
    <url>%2F2019%2F01%2F13%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E6%97%8B%E8%BD%AC%E7%9F%AB%E6%AD%A3%2F</url>
    <content type="text"><![CDATA[前言这学期我们上了一门软件工程课和数字图像处理课，软件工程课课设要求大家设计一款软件。作为一个学生助理，我早就对学校的问卷调查不满意了，填写完的纸质表格竟然还要输入成电子表格，人工手动输入，未免也太难受了。所以结合我所学的知识，我准备利用python+opencv做一款纸质文档识别软件，专门识别纸质表格转化成为电子表格。 原理因为表格不仅仅有文字信息，同时还有位置信息，所以在识别表格时我们应该识别出文字和位置信息。文字信息一般是可以用OCR技术识别出来，这部分有很多相关的模块、库可以使用，但是位置信息的识别就有一定的困难。所以我们首先要解决这个位置信息。 当我们拿到一张纸质表格时，一般来说都会有框体，这个时候我们只要把最外围的框体识别出来，接着递归识别所有框体，然后再对所有小框体进行进行文字识别操作就会很简单。 实现方法很明显，第一步是要解决最外头的这个框线识别问题。一般来说，不是每个人拍照都是横平竖直的，所以我们必须要对原始图像进行适当的倾斜矫正。在opencv里，我们有两个很好用的函数来进行这样的操作：先用cv2.getPerspectiveTransform（target_points, four_points）得到旋转矩阵然后再用cv2.warpPerspective(img, M, (weight, height))进行透视变换。下面是该函数的一个演示如果我们知道屏幕中间的四个角的位置，那么我们就能把它通过函数给校正 1234567891011121314151617181920212223# -*- coding: utf-8 -*-"""Created on Sun Jan 13 09:22:51 2019@author: lei"""import cv2import numpy as npimg= cv2.imread('rowRotate.jpg')#读取原始图片target_points =[[278,189],[758,336],[570,1034],[65,900]]#这里我们通过人工的方式读出四个角点A，B，C，Dheight = img.shape[0]weight = img.shape[1]four_points= np.array(((0, 0), (weight - 1, 0), (weight - 1, height - 1), (0, height - 1)), np.float32)target_points = np.array(target_points, np.float32)#统一格式M = cv2.getPerspectiveTransform(target_points, four_points)Rotated= cv2.warpPerspective(img, M, (weight, height))cv2.imwrite("Rotated.jpg",Rotated) 程序运行效果图旋转裁切的效果很棒，但这只是人工的方式寻找四个角点，可不可以想办法实现程序自动裁切呢？对于这个问题，我经过大量地查阅资料和实验，终于发现了一个比较好的办法。那就是先把轮廓线找到，然后找轮廓线里面的角点。由于篇幅关系，我将把这个留在后面讲解]]></content>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
        <tag>旋转矫正</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git无法推送代码至仓库]]></title>
    <url>%2F2018%2F11%2F24%2FGit%E6%97%A0%E6%B3%95%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%E8%87%B3%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[问题：fatal: Could not read from remote repository. Please make sure you have the correct access rightsand the repository exists. 解决办法：出现这种情况是因为Git的SSH对当前项目失效，所以认为你没有权限，所以你得重新生成一个SSH密钥。 1ssh-keygen 一直确定到底，然后去网页端替换SSH]]></content>
      <tags>
        <tag>Git</tag>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32GPIO无法工作原因]]></title>
    <url>%2F2018%2F08%2F29%2Fstm32GPIO%E6%97%A0%E6%B3%95%E5%B7%A5%E4%BD%9C%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[最近在调试0.96寸oled时遇见了一个非常奇怪的问题，当我软件模拟spi时某些引脚死活不工作，一开始我以为是我的板子问题，但实际上是stm32对于某些引脚默认有一些操作，导致无法正常的初始化。 stm32默认开启的JTAG模式对于开发者来说，stm32很多引脚都有非常丰富的功能，能让我们开发者进行很多功能的开发，但是正是因为引脚功能太过丰富，说明文档虽然相比其他芯片已经很清晰了，但是依然会忽略某些重要的东西。比如说stm32对于某些脚默认开启了JTAG模式，假如没有显式声明取消JTAG功能，那么关于这些引脚的所有功能初始化都会失败。根据stm32f103的操作手册，PA13，PA14，PA15，PB3，PB4，这几个脚都是默认开启了JTAG模式，所以当我们需要用到这几个脚时，必须声明12RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO ,ENABLE);//重映射需要先使能AFIO时钟GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);//只关闭JTAG而保留SWD GPIO引脚问题一般来说，碰到GPIO引脚问题，第一步都是检查是否虚焊，假如没有虚焊的话，检查代码配置问题，如果代码配置也没有问题的话，就必须回到操作手册上看引脚定义，看该引脚是否可能存在默认的引脚配置，比如上文提到的JTAG模式。]]></content>
      <tags>
        <tag>stm32f103</tag>
        <tag>GPIO</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python打包的艰难之旅]]></title>
    <url>%2F2018%2F08%2F13%2Fpython%E6%89%93%E5%8C%85%E7%9A%84%E8%89%B0%E9%9A%BE%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[前几日，我做了一个简单地划词翻译工具，还挺好用的，但是作为一个python脚本，每次都要打开命令行去执行或者是用spyder太过麻烦了，本来就是想简单简单再简单，所以一心搞事的我又踏上了艰难的python打包之旅。python打包成exe执行文件是挺费劲的，毕竟python本身是没有这个工具的。我用的anaconda也没有这个功能。经过查阅资料，我发现其实python有两个比较好用的打包工具，一个是pyinstaller，一个是py2exe。当时年轻的我还没有意识到，我即将为我的冲动付出时间的代价。 安装模块 py2exe因为我用的是python2.7，我一看py2exe名字里带有2，心想没错了，决定就是你了，于是我在命令行界面如狂风骤雨般地敲打出 pip install py2exe，黑色屏幕一阵闪动，跳出血红大字：你的版本太低，看不上你。原来py2exe只能在3.3版本或者更新的版本才能使用。遂放弃 pyinstaller照样是如狂风骤雨般地敲打出pip install pyinstaller，哈哈，一次成功。 pyinstaller微操指南pyinstaller使用方法还挺简单，在命令行界面跳转到自己的脚本目录下，输入1pyinstaller *.py 立马开始工作，很快，命令行显示生成成功。与此同时在此目录下出现了一个build文件夹，打开文件夹，出现以脚本命名的文件夹，点进去，有个exe文件，说时迟那时快，我的鼠标立马就点过去，一个黑框闪过，结果啥也没有？？？正在我百思不得其解时，我发现一个warntemp.txt，点进去。哇，一堆错误——全是missing，pyinstaller这个也是神奇，就算失败了也能给你生成出来，佩服佩服。但是佩服归佩服，怎么解决呢？原来，pyinstaller有个参数-p 文件路径，输入了此路径，就可以解决找不到模块的问题了。12pyinstaller *.py -p E:\DevelopTools\Anaconda2\Lib\site-packages#我这里模块路径是这个，大家灵活点找到python模块的文件夹 重新再来一遍，这一次，黑框闪过，成功运行。pyinstaller 一般有几个参数 ：-w（不带命令行框）-F（一整个文件，单EXE） bug总是来得措手不及我内心这个激动啊，好，我马上给我的小伙伴发一个，亮瞎他们的狗眼。我开开心心地将它挪到桌面，突然就不行了，难道是我的心不灵，还是这个打包器太倔，只能指定位置运行？于是我又给他小心翼翼地放回原来的地方，也还是不行。那我重新生成总可以了吧，它出现在那里，似乎一切都没变过，但是，却他已经不再是他了，他死了，永远的死了。于是我只能动用重启大法，重启之后，一切都是新鲜的模样，什么都是新的，每一个电子都似乎焕发了新的生机。他也随着电子，一起睁开了眼，复制，翻译，是那么的行云流水。我的眼眶不禁开始湿润，我开始思考，究竟是什么，是那隐藏在幽暗电子空穴里涌动的bug，还是那冥冥中的天意，亦或者是我那摇摇欲坠，随风而去的发丝还没离去，让它不满意，发脾气，闹别扭？我踏上了一条寻找答案的道路，我左手谷歌，右手百度，一下去stackoverflow寻经问道，一下去cnds广布英雄帖，走过一道道荒芜的答案，尝试每一种可能的解法，只为我的程序能够让小伙伴的眼亮瞎。这样的我难道就不受世人待见吗，我在黑夜里忍受这血丝遍布的瞳孔带给我的痛楚，我在黎明前悄悄打开我的屏幕享受我的孤独，我一次又一次，失败又失败，可是我，永不动摇。我再一次打开warntemp.txt，里面还是存在着错误，我一个又一个的添加路径，一遍又一遍的输入指令，我感觉我的生命，一点一点归于死寂。 bug之死苍天不负有心人，bug终能死我手。我用cmd打开我移动过的程序，里面赫然说着，有个模块跳出，哈哈，原来如此，原来是我的模块问题1234567def getCopyText(): wc.OpenClipboard() copy_text = wc.GetClipboardData(win32con.CF_TEXT) copy_text=copy_text.strip().replace("\r\n"," ").replace("\n"," ").replace("\r"," ") wc.CloseClipboard() return copy_text#返会是否有新的复制数据 乍一看，问题无有，但是由于我们打开了剪切板，而windows的剪切板功能超级强大，它不仅能够复制文字，还能复制文档，程序，当我移动程序的时候，我实际上是将程序复制到了剪切板，此时这个模块就不能正常工作，就会抛出异常，我终于明白了问题所在，我复制一段文字，打开程序，完美运行，nice！bug已死，黄天当立，我也要继续下一段代码的编写。程序附上点击下载]]></content>
      <tags>
        <tag>python</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现划词翻译]]></title>
    <url>%2F2018%2F08%2F11%2Fpython%E5%AE%9E%E7%8E%B0%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[最近因为编程，需要大量地看一些说明文档，无奈说明文档都是英文的，可把我这个半桶水折腾死了，太多词汇不知道，一个个复制翻译太麻烦了。于是我根据自己的需要，用python写了一个划词翻译。 一：使用逻辑由于我是看PDF文档，用的是一款轻量级的PDF阅读器（SumatraPDF），这款阅读器只有5M，但是阅读很舒服很流畅，渲染也很到位。但是没有其他阅读器有许多强大功能，比如说划词翻译。我的想法是一旦发现我复制就可以在当前鼠标位置显示一个翻译结果框。基于这个想法，我一开始准备使用MFC编写，因为MFC能够轻易获得系统消息，钩子调用十分简单。可是我把检测复制，显示文本框都做好的时候，发现一个悲伤的事实，c++的http库实在是不怎么样，竟然无法访问http://地址，经过一晚的尝试——失败，这才打算使用python。啰啰嗦嗦一大堆，我现在把我的逻辑说下吧。 二：需要引用的库因为要联网所以需要urllib，解析网页需要json，读取剪切板数据需要win32clipboard，获得当前鼠标信息用PyMouse，生成文本框Tkinter，定时器time。python为什么强大，就在于集成库的易用性和多样性，有什么需要就pip install 装就行，这点比c++强太多了。123456import urllib #http连接需要用到import json #解析网页数据用import win32clipboard as wc #读取剪切板数据from pymouse import PyMouse #获得当前鼠标信息import Tkinter #自带的GUI库，生成文本框import time #定时器，减少占用 三：代码实现 我这里先定义了四个函数，方便后面实现功能，下面有详细解释和代码 123456789101112131415161718192021222324252627#PyMouse得到的是2维字符串，但是tkinter生成窗体时需要的是类似（100*100+x+y）的字符串，100*100是窗口大小，xy是坐标点。我在这里调整了窗体出现的位置，方便查看翻译后关闭窗口，def transMousePosition(): m = PyMouse() return "300x50+"+str(m.position()[0]-300)+"+"+str(m.position()[1]-15)#获得剪切板数据，同时清洗数据将换行符等去掉def getCopyText(): wc.OpenClipboard() copy_text = wc.GetClipboardData(win32con.CF_TEXT) copy_text=copy_text.strip().replace("\r\n"," ").replace("\n"," ").replace("\r"," ") wc.CloseClipboard() return copy_text #返会是否有新的复制数据，cmp函数用于比较2个对象，如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。def newCopyData(): if cmp(currentData,str(getCopyText()))!=0: return 1 else: return 0#得到所有翻译文本，因为json数据是按照每一句每一句接收的，所以当我们要获得一大段文本翻译时，必须要遍历数据def getTransText(jsonText): text='' for listValue in jsonText['translateResult'][0]: text+= listValue['tgt'] return text 主程序 123456789101112131415161718192021222324if __name__ == '__main__': req_url = 'http://fanyi.youdao.com/translate' # 创建连接接口，这里是有道词典的借口 # 创建要提交的数据 currentData=str(getCopyText()) Form_Date = &#123;&#125; Form_Date['doctype'] = 'json' while True: if newCopyData(): currentData=str(getCopyText())#取得当前剪切板数据 Form_Date['i'] = currentData # 传递数据 data = urllib.urlencode(Form_Date).encode('utf-8') #数据转换 response = urllib.urlopen(req_url, data) #提交数据并解析 html = response.read().decode('utf-8') #服务器返回结果读取 translate_results = getTransText(json.loads(html)) #以json格式载入 position=transMousePosition()#取得当前鼠标位置 top = Tkinter.Tk()#窗口初始化 top.wm_attributes('-topmost',1)#置顶窗口 top.geometry(position)#指定定位生成指定大小窗口 e=Tkinter.Text()#生成文本框部件 e.insert(1.0,translate_results)#插入数据 e.pack()#将部件打包进窗口 top.mainloop()# 进入消息循环 currentData=str(getCopyText()) time.sleep(1) 到此，我们划词翻译程序就已经完成了，虽然不太美观。而且美中不足的是我没有想到一个好的办法退出程序，相当于一个死循环在里面，只有强行退出，不知道谁有好办法能够解决这个问题，如果有，请和我联系ltyplay@outlook.com 总结如果要实现什么功能，python该是最好的胶水了，c++的http库实在是太坑了，浪费我好多小时。下面源代码附上，给大家参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding: utf-8 -*-"""Created on Sat Aug 11 08:24:48 2018@author: ltengy"""import urllib #http连接需要用到import json #解析网页数据用import win32clipboard as wc #读取剪切板数据from pymouse import PyMouse #获得当前鼠标信息import Tkinter #自带的GUI库，生成文本框import time #定时器，减少占用import win32concurrentData='' #PyMouse得到的是2维字符串，但是tkinter生成窗体时需要的是类似（100*100+x+y）的字符串，100*100是窗口大小，xy是坐标点。def transMousePosition(): m = PyMouse() return "300x50+"+str(m.position()[0]-300)+"+"+str(m.position()[1]-15)#获得剪切板数据 def getCopyText(): wc.OpenClipboard() copy_text = wc.GetClipboardData(win32con.CF_TEXT) copy_text=copy_text.strip().replace("\r\n"," ").replace("\n"," ").replace("\r"," ") wc.CloseClipboard() return copy_text#返会是否有新的复制数据def newCopyData(): if cmp(currentData,str(getCopyText()))!=0: return 1 else: return 0#得到所有翻译文本def getTransText(jsonText): text='' for listValue in jsonText['translateResult'][0]: text+= listValue['tgt'] return text if __name__ == '__main__': req_url = 'http://fanyi.youdao.com/translate' # 创建连接接口，这里是有道词典的借口 # 创建要提交的数据 currentData=str(getCopyText()) Form_Date = &#123;&#125; Form_Date['doctype'] = 'json' while True: if newCopyData(): currentData=str(getCopyText())#取得当前剪切板数据 Form_Date['i'] = currentData # 传递数据 data = urllib.urlencode(Form_Date).encode('utf-8') #数据转换 response = urllib.urlopen(req_url, data) #提交数据并解析 html = response.read().decode('utf-8') #服务器返回结果读取 translate_results = getTransText(json.loads(html)) #以json格式载入 position=transMousePosition()#取得当前鼠标位置 top = Tkinter.Tk()#窗口初始化 top.wm_attributes('-topmost',1)#置顶窗口 top.geometry(position)#指定定位生成指定大小窗口 e=Tkinter.Text()#生成文本框部件 e.insert(1.0,translate_results)#插入数据 e.pack()#将部件打包进窗口 top.mainloop()# 进入消息循环 currentData=str(getCopyText()) time.sleep(1)]]></content>
      <tags>
        <tag>python</tag>
        <tag>划词翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于自定义标签库找不到路径的解决办法]]></title>
    <url>%2F2018%2F08%2F07%2F%E5%85%B3%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%E5%BA%93%E6%89%BE%E4%B8%8D%E5%88%B0%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言最近在学习怎么使用servlet进行自定义标签库的使用，发现一个问题，当我按照书上的代码复现时，死活都找不到标签库。进过分析查找资料，终于解决了这个棘手的问题。 问题说明死活查找不到自己的自定义标签库，错误代码500。网上很多人都遇到过这个毛病，有人说添加xml可以解决，有人说换个路径可以解决，经过尝试，终于解决我的这个棘手问题。 解决办法添加xml1234&lt;taglib&gt; &lt;taglib-uri&gt;mytags&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/jsp/mytaglib.tld&lt;/taglib-location&gt;&lt;/taglib&gt; 经尝试，无法解决我的错误 去掉斜杠 去掉/WEB-INF/前面的斜杠/，也不太管用。 将双引号改为单引号 将双引号改为单引号，重启myesclipse，解决问题。]]></content>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
        <tag>自定义标签库</tag>
        <tag>路径错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于spfk主题的自动摘要]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%9F%BA%E4%BA%8Espfk%E4%B8%BB%E9%A2%98%E7%9A%84%E8%87%AA%E5%8A%A8%E6%91%98%E8%A6%81%2F</url>
    <content type="text"><![CDATA[前言最近又开始捣鼓我的博客，发现我的博客首页一进去就是个空白，对比spfk制作的博客，我陷入了沉思。是不是我的配置错误，还是说我漏了什么文件没有clone。不断的F12调试，重新clone，查找资料，发现原来不是配置的锅，也不是文件缺少，而是没有打上这句话.1&lt;!-- more --&gt; 我赶快把所有的md文件都在合理的位置上打上标记，但是对于一个coder，能不手动就不手动，于是又开始查找相关资料，开始搞事。 自动摘要的原理很多自动摘要的原理都很简单，比如说多少个字符截断，像next主题就是这么干的，但是，那也太难受了，遇到了有代码的，分段的，基本上就成智障了，还得操心。 移植代码参考这位老哥的想法https://blog.zthxxx.me/posts/Hexo-Automatic-Add-ReadMore感觉挺好的，于是动手移植了下代码，不过每个主题的配置都略有不同，所以移植也需要一点点编程知识。先配置_config.yml，在文末增加如下代码1234auto_excerpt: enable: true lines: 1#自定义自动摘要几行 找到themes\hexo-theme-spfk\layout_partial 文件下的article.ejs，用文本编辑器打开，将1&lt;div class="article-entry" itemprop="articleBody"&gt;到&lt;% if (!index &amp;&amp; post.toc != false &amp;&amp; !is_page())&#123; %&gt; 之间的内容替换掉,就可以实现自动readmore了。代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;div class="article-entry" itemprop="articleBody"&gt; &lt;% var show_all_content = true %&gt; &lt;% if (index) &#123; %&gt; &lt;% if (post.excerpt) &#123; %&gt; &lt;% show_all_content = false %&gt; &lt;p&gt;&lt;%- post.excerpt %&gt;&lt;/p&gt; &lt;% &#125; else if (theme.auto_excerpt.enable) &#123; %&gt; &lt;% var br_position = 0 %&gt; &lt;% for (var br_count = 0; br_count &lt; theme.auto_excerpt.lines; br_count++) &#123; %&gt; &lt;% br_position = post.content.indexOf('\n',br_position + 1) %&gt; &lt;% if(br_position &lt; 0) &#123; break &#125; %&gt; &lt;% &#125; %&gt; &lt;% if(br_position &gt; 0) &#123; %&gt; &lt;% show_all_content = false %&gt; &lt;p&gt;&lt;%- post.content.substring(0, br_position + 1) %&gt;&lt;p&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;% &#125; else &#123; %&gt; &lt;% if (post.toc) &#123; %&gt; &lt;div id="toc" class="toc-article"&gt; &lt;strong class="toc-title"&gt;&lt;%= __('article.catalogue') %&gt;&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;% if (show_all_content) &#123; %&gt; &lt;%- post.content %&gt; &lt;% &#125; %&gt; &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.toc)) &amp;&amp; !index)&#123; %&gt; &lt;div class="page-reward"&gt; &lt;p&gt;&lt;a href="javascript:void(0)" onclick="dashangToggle()" class="dashang"&gt;赏&lt;/a&gt;&lt;/p&gt; &lt;div class="hide_box"&gt;&lt;/div&gt; &lt;div class="shang_box"&gt; &lt;a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()"&gt;×&lt;/a&gt; &lt;div class="shang_tit"&gt; &lt;p&gt;&lt;%= theme.reward_wording1%&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="shang_payimg"&gt; &lt;img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" /&gt; &lt;/div&gt; &lt;div class="pay_explain"&gt;&lt;%= theme.reward_wording2%&gt;&lt;/div&gt; &lt;div class="shang_payselect"&gt; &lt;% if(theme.alipay) &#123;%&gt; &lt;div class="pay_item checked" data-id="alipay"&gt; &lt;span class="radiobox"&gt;&lt;/span&gt; &lt;span class="pay_logo"&gt;&lt;img src="&lt;%= theme.alipay%&gt;" alt="支付宝" /&gt;&lt;/span&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% if(theme.weixin) &#123;%&gt; &lt;div class="pay_item" data-id="wechat"&gt; &lt;span class="radiobox"&gt;&lt;/span&gt; &lt;span class="pay_logo"&gt;&lt;img src="&lt;%= theme.weixin%&gt;" alt="微信" /&gt;&lt;/span&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class="shang_info"&gt; &lt;p&gt;打开&lt;span id="shang_pay_txt"&gt;支付宝&lt;/span&gt;扫一扫，即可进行扫码打赏哦&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(".pay_item").click(function()&#123; $(this).addClass('checked').siblings('.pay_item').removeClass('checked'); var dataid=$(this).attr('data-id'); $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg"); $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信"); &#125;); function dashangToggle()&#123; $(".hide_box").fadeToggle(); $(".shang_box").fadeToggle(); &#125; &lt;/script&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;% if (index)&#123; %&gt; &lt;div class="article-info article-info-index"&gt; &lt;%if(post.top)&#123;%&gt; &lt;div class="article-pop-out tagcloud"&gt; &lt;a class=""&gt;置顶&lt;/a&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;%- partial('post/category') %&gt; &lt;%- partial('post/tag') %&gt; &lt;% if (index &amp;&amp; (post.description || post.excerpt ||!show_all_content))&#123; %&gt; &lt;p class="article-more-link"&gt; &lt;a &lt;% if (!theme.excerpt_link)&#123; %&gt;class="hidden"&lt;% &#125; %&gt; href="&lt;%- url_for(post.path) %&gt;#more"&gt;&lt;%= theme.excerpt_link %&gt; &gt;&gt;&lt;/a&gt; &lt;/p&gt; &lt;% &#125; %&gt; &lt;div class="clearfix"&gt;&lt;/div&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;% if (!index)&#123; %&gt; &lt;%- partial('post/nav') %&gt; &lt;% &#125; %&gt;&lt;/article&gt; 效果效果如图所示 问题自动摘要的行数是对应正文而不包括标题，所以当行数大于一时容易出问题。有时间我准备写一个小标题的摘要配置，先留坑吧 文档下载我把我修改的配置文件传上来，供大家使用点击下载]]></content>
      <tags>
        <tag>spfk</tag>
        <tag>ReadMore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实现验证码demo]]></title>
    <url>%2F2018%2F08%2F04%2F%E9%AA%8C%E8%AF%81%E7%A0%81demo%2F</url>
    <content type="text"><![CDATA[最近要做一个网站，要求实现验证码程序，经过不断调试，终于成功实现功能。 一：验证码生成类生成验证码的话需要用到java的Graphics类库，画出一个验证码废话不多说，直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package verificationCode;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.awt.image.RenderedImage;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.util.HashMap;import java.util.Map;import java.util.Random;import javax.imageio.ImageIO;public class generateCode &#123; private static int width = 150;// 定义图片的width private static int height = 48;// 定义图片的height private static int codeCount = 4;// 定义图片上显示验证码的个数 private static int xx = 25; private static int fontHeight = 42; private static int codeY = 42; private static char[] codeSequence = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' &#125;; /** * 生成一个map集合 * code为生成的验证码 * codePic为生成的验证码BufferedImage对象 * @return */ public static Map&lt;String,Object&gt; generateCodeAndPic() &#123; // 定义图像buffer BufferedImage buffImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); // Graphics2D gd = buffImg.createGraphics(); // Graphics2D gd = (Graphics2D) buffImg.getGraphics(); Graphics gd = buffImg.getGraphics(); // 创建一个随机数生成器类 Random random = new Random(); // 将图像填充为白色 gd.setColor(Color.WHITE); gd.fillRect(0, 0, width, height); // 创建字体，字体的大小应该根据图片的高度来定。 Font font = new Font("Fixedsys", Font.BOLD, fontHeight); // 设置字体。 gd.setFont(font); // 画边框。 gd.setColor(Color.BLACK); gd.drawRect(0, 0, width - 1, height - 1); gd.setFont(font); // 随机产生40条干扰线，使图象中的认证码不易被其它程序探测到。 int red = 0, green = 0, blue = 0; // randomCode用于保存随机产生的验证码，以便用户登录后进行验证。 StringBuffer randomCode = new StringBuffer(); // 随机产生codeCount数字的验证码。 for (int i = 0; i &lt; codeCount; i++) &#123; // 得到随机产生的验证码数字。 String code = String.valueOf(codeSequence[random.nextInt(36)]); // 产生随机的颜色分量来构造颜色值，这样输出的每位数字的颜色值都将不同。 red = random.nextInt(255); green = random.nextInt(255); blue = random.nextInt(255); // 用随机产生的颜色将验证码绘制到图像中。 gd.setColor(new Color(red, green, blue)); gd.drawString(code, (i + 1) * xx, codeY); // 将产生的四个随机数组合在一起。 randomCode.append(code); &#125; for (int i = 0; i &lt; 60; i++) &#123; red = random.nextInt(255); green = random.nextInt(255); blue = random.nextInt(255); // 用随机产生的颜色将验证码绘制到图像中。 gd.setColor(new Color(red, green, blue)); int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(50); int yl = random.nextInt(50); gd.drawLine(x, y, x + xl, y + yl); &#125; Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); //存放验证码 map.put("code", randomCode); //存放生成的验证码BufferedImage对象 map.put("codePic", buffImg); return map; &#125; public static void main(String[] args) throws Exception &#123; //创建文件输出流对象 File file = new File("WebRoot/image/"+System.currentTimeMillis()+".jpg"); FileOutputStream out = null; try &#123; if (!file.exists()) &#123; // 先得到文件的上级目录，并创建上级目录，在创建文件 file.getParentFile().mkdir(); file.createNewFile(); &#125; out = new FileOutputStream(file); Map&lt;String,Object&gt; map = generateCode.generateCodeAndPic(); ImageIO.write((RenderedImage) map.get("codePic"), "jpeg", out); System.out.println("验证码的值为："+map.get("code")); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 二：验证码验证类12345678910111213141516171819202122232425262728293031323334353637383940package verificationCode;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@WebServlet("/checkCode")public class checkCode extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String code = request.getParameter("code"); response.setCharacterEncoding("utf-8");//保证格式正确 response.setContentType("text/html"); // 验证验证码 String sessionCode = request.getSession().getAttribute("code").toString(); if (code != null &amp;&amp; !"".equals(code) &amp;&amp; sessionCode != null &amp;&amp; !"".equals(sessionCode)) &#123; if (code.equalsIgnoreCase(sessionCode)) &#123; response.getWriter().println("验证通过！"); &#125; else &#123; response.getWriter().println("验证失败！"); &#125; &#125; else &#123; response.getWriter().println("验证失败！"); &#125; &#125;&#125; 三：验证码传输类用到doget方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package verificationCode;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.awt.image.RenderedImage;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import verificationCode.generateCode;/** * Servlet implementation class CodeServlet */@WebServlet("/getCode")public class CodeServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 调用工具类生成的验证码和验证码图片 Map&lt;String, Object&gt; codeMap = generateCode.generateCodeAndPic(); // 将四位数字的验证码保存到Session中。 HttpSession session = req.getSession(); session.setAttribute("code", codeMap.get("code").toString()); // 禁止图像缓存。 resp.setHeader("Pragma", "no-cache"); resp.setHeader("Cache-Control", "no-cache"); resp.setDateHeader("Expires", 0); resp.setContentType("image/jpeg"); // 将图像输出到Servlet输出流中。 ServletOutputStream sos; try &#123; sos = resp.getOutputStream(); ImageIO.write((RenderedImage) codeMap.get("codePic"), "jpeg", sos); sos.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 四：jsp验证demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;验证码页面&lt;/title&gt;&lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/js/jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/checkCode" method="post"&gt; 请输入验证码：&lt;input type="text" name="code" style="width: 80px;" /&gt; &lt;div id=random&gt; &lt;img id="imgObj" alt="验证码" src="$&#123;pageContext.request.contextPath&#125;/getCode"&gt; &lt;/div&gt;&lt;button id="b01" type="button"&gt;改变内容&lt;/button&gt;&lt;br/&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; $(function() &#123; //response.getWriter().println("验证失败！"); &#125;); $("#b01").click( function changeImg() &#123; $("#random").html("&lt;img id='imgObj' alt='验证码' src='$&#123;pageContext.request.contextPath&#125;/getCode'&gt;") var imgSrc = $("#imgObj"); var src = imgSrc.attr("src"); imgSrc.attr("src", chgUrl(src)); &#125;); // 时间戳 // 为了使每次生成图片不一致，即不让浏览器读缓存，所以需要加上时间戳 function chgUrl(url) &#123; var timestamp = (new Date()).valueOf(); url = url.substring(0, 20); if ((url.indexOf("&amp;") &gt;= 0)) &#123; url = url + "×tamp=" + timestamp; &#125; else &#123; url = url + "?timestamp=" + timestamp; &#125; return url; &#125;&lt;/script&gt;&lt;/html&gt; 总结虽然只是一个小小的demo，但是实际上用到了许多知识，比如生成验证码的画图，传输验证码doget，验证验证码的dopost和ajax动态更换验证码，麻雀虽小五脏俱全啊。 参考网址https://www.cnblogs.com/nanyangke-cjz/p/7049281.html]]></content>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ccs811调试指南]]></title>
    <url>%2F2018%2F08%2F04%2Fccs811%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言最近使用CCS811这一款集成环境参数测量芯片，由于CCS811本身的原因，导致调试颇为不顺利。现在已经调试出来，把自己的经验分享给大家。主控芯片stm32f103。 问题一：无法正常读取硬件id及状态这个问题有可能是： 1.进行了某些误操作，导致CCS811芯片本身跑飞，所以怎么复位都不能读取。解决办法是对芯片复位，即INT脚接地2.IIC通讯本身有问题，讲IIC通讯的读和写里的延迟加大，至少5us 问题二：从boot模式转换到测量模式失败当上面的参数能读取出来的时候，其实通讯本身已经没有问题，但是由于CCS811内部集成的MCU需要一定的时间转换模式，即当我们发送测量转换指令后，必须等待至少180us时间，才能够对ccs811进行读写操作，假如提前读写便导致CCS811跑飞。解决办法，当发送转换指令时必须等待180us，代码如下 12345678910111213141516//测量数据前必须开启void app_Start(void)&#123; nWAKE=0; delay_us(50); IIC_Start(); IIC_Send_Byte(WRIT); //发送写命令 if(IIC_Wait_Ack())&#123; IIC_Stop();return;&#125; IIC_Send_Byte(0xF4); delay_us(180); //必须等待180us以上才能够收到应答 if(IIC_Wait_Ack())&#123;IIC_Stop();return;&#125; IIC_Stop(); nWAKE=1;&#125; 问题三：进入测量模式但无法读取环境参数这个问题也是CCS811内部集成的MCU的锅，当进入测量模式后，CCS811的IIC通讯就变慢了，也就是说，IIC通讯必须变慢，否则CCS811反应不过来。解决办法是调整IIC读写速度，读写延迟至少50us。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142//测量数据前必须开启void IIC_Send_Byte(u8 txd)&#123; u8 t; SDA_OUT(); IIC_SCL=0;//拉低时钟开始数据传输 for(t=0;t&lt;8;t++) &#123; if((txd&amp;0x80)&gt;&gt;7) IIC_SDA=1; else IIC_SDA=0; txd&lt;&lt;=1; delay_us(50); //对TEA5767这三个延时都是必须的 IIC_SCL=1; delay_us(50); IIC_SCL=0; delay_us(50); &#125; &#125; //读1个字节，ack=1时，发送ACK，ack=0，发送nACK u8 IIC_Read_Byte(unsigned char ack)&#123; unsigned char i,receive=0; SDA_IN();//SDA设置为输入 for(i=0;i&lt;8;i++ ) &#123; IIC_SCL=0; delay_us(50); IIC_SCL=1; receive&lt;&lt;=1; if(READ_SDA)receive++; delay_us(50); &#125; if (!ack) IIC_NAck();//发送nACK else IIC_Ack(); //发送ACK return receive;&#125; 其他问题按照器件手册上的介绍都可以解决 结束语调试一块板子真的很不容易，尤其是官方文档写的奇奇怪怪的。一开始以为IIC有问题，调了两三天，后面才明白怎么回事，如果有一块逻辑分析仪应该不用这么久吧。附上我写的库，祝大家能够早日调出来。点击下载]]></content>
      <tags>
        <tag>stm32f103</tag>
        <tag>ccs811</tag>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 45道经典练习]]></title>
    <url>%2F2018%2F06%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言最近学了SQL，但对查询等操作还是不熟练，于是网上找了一套题目自己做，从实际操纵中一点一点学习sql的语句，相信大家耐心做完题后，会和我一样对sql有一个新的领悟 一：准备工作准备建库下面是建库代码12345678910111213141516171819202122CREATE TABLE students(sno VARCHAR(3) NOT NULL, sname VARCHAR(4) NOT NULL,ssex VARCHAR(2) NOT NULL, sbirthday DATETIME,class VARCHAR(5))CREATE TABLE courses(cno VARCHAR(5) NOT NULL, cname VARCHAR(10) NOT NULL, tno VARCHAR(10) NOT NULL)CREATE TABLE scores (sno VARCHAR(3) NOT NULL, cno VARCHAR(5) NOT NULL, degree NUMERIC(10, 1) NOT NULL) CREATE TABLE teachers (tno VARCHAR(3) NOT NULL, tname VARCHAR(4) NOT NULL, tsex VARCHAR(2) NOT NULL, tbirthday DATETIME NOT NULL, prof VARCHAR(6), depart VARCHAR(10) NOT NULL) 插入数据代码1234567891011121314151617181920212223242526272829INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (108 ,'曾华' ,'男' ,'1977-09-01',95033);INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (105 ,'匡明' ,'男' ,'1975-10-02',95031);INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (107 ,'王丽' ,'女' ,'1976-01-23',95033);INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (101 ,'李军' ,'男' ,'1976-02-20',95033);INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (109 ,'王芳' ,'女' ,'1975-02-10',95031);INSERT INTO STUDENTS (SNO,SNAME,SSEX,SBIRTHDAY,CLASS) VALUES (103 ,'陆君' ,'男' ,'1974-06-03',95031);INSERT INTO COURSES(CNO,CNAME,TNO)VALUES ('3-105' ,'计算机导论',825);INSERT INTO COURSES(CNO,CNAME,TNO)VALUES ('3-245' ,'操作系统' ,804);INSERT INTO COURSES(CNO,CNAME,TNO)VALUES ('6-166' ,'数据电路' ,856);INSERT INTO COURSES(CNO,CNAME,TNO)VALUES ('9-888' ,'高等数学' ,100);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (103,'3-245',86);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (105,'3-245',75);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (109,'3-245',68);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (103,'3-105',92);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (105,'3-105',88);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (109,'3-105',76);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (101,'3-105',64);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (107,'3-105',91);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (108,'3-105',78);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (101,'6-166',85);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (107,'6-106',79);INSERT INTO SCORES(SNO,CNO,DEGREE)VALUES (108,'6-166',81);INSERT INTO TEACHERS(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (804,'李诚','男','1958-12-02','副教授','计算机系');INSERT INTO TEACHERS(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (856,'张旭','男','1969-03-12','讲师','电子工程系');INSERT INTO TEACHERS(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (825,'王萍','女','1972-05-05','助教','计算机系');INSERT INTO TEACHERS(TNO,TNAME,TSEX,TBIRTHDAY,PROF,DEPART) VALUES (831,'刘冰','女','1977-08-14','助教','电子工程系'); 问题:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152531、 查询Student表中的所有记录的Sname、Ssex和Class列。2、 查询教师所有的单位即不重复的Depart列。3、 查询Student表的所有记录。4、 查询Score表中成绩在60到80之间的所有记录。5、 查询Score表中成绩为85，86或88的记录。6、 查询Student表中“95031”班或性别为“女”的同学记录。7、 以Class降序查询Student表的所有记录。8、 以Cno升序、Degree降序查询Score表的所有记录。9、 查询“95031”班的学生人数。10、查询Score表中的最高分的学生学号和课程号。11、查询‘3-105’号课程的平均分。12、查询Score表中至少有5名学生选修的并以3开头的课程的平均分数。13、查询最低分大于70，最高分小于90的Sno列。14、查询所有学生的Sname、Cno和Degree列。15、查询所有学生的Sno、Cname和Degree列。16、查询所有学生的Sname、Cname和Degree列。17、查询“95033”班所选课程的平均分。18、假设使用如下命令建立了一个grade表：create table grade(low number(3,0),upp number(3),rank char(1));insert into grade values(90,100,’A’);insert into grade values(80,89,’B’);insert into grade values(70,79,’C’);insert into grade values(60,69,’D’);insert into grade values(0,59,’E’);commit;现查询所有同学的Sno、Cno和rank列。19、查询选修“3-105”课程的成绩高于“109”号同学成绩的所有同学的记录。20、查询score中选学一门以上课程的同学中分数为非最高分成绩的记录。21、查询成绩高于学号为“109”、课程号为“3-105”的成绩的所有记录。22、查询和学号为108的同学同年出生的所有学生的Sno、Sname和Sbirthday列。23、查询“张旭“教师任课的学生成绩。24、查询选修某课程的同学人数多于5人的教师姓名。25、查询95033班和95031班全体学生的记录。26、查询存在有85分以上成绩的课程Cno.27、查询出“计算机系“教师所教课程的成绩表。28、查询“计算机系”与“电子工程系“不同职称的教师的Tname和Prof。29、查询选修编号为“3-105“课程且成绩至少高于选修编号为“3-245”的同学的Cno、Sno和Degree,并按Degree从高到低次序排序。30、查询选修编号为“3-105”且成绩高于选修编号为“3-245”课程的同学的Cno、Sno和Degree.31、查询所有教师和同学的name、sex和birthday.32、查询所有“女”教师和“女”同学的name、sex和birthday.33、查询成绩比该课程平均成绩低的同学的成绩表。34、查询所有任课教师的Tname和Depart.35 查询所有未讲课的教师的Tname和Depart. 36、查询至少有2名男生的班号。37、查询Student表中不姓“王”的同学记录。38、查询Student表中每个学生的姓名和年龄。39、查询Student表中最大和最小的Sbirthday日期值。40、以班号和年龄从大到小的顺序查询Student表中的全部记录。41、查询“男”教师及其所上的课程。42、查询最高分同学的Sno、Cno和Degree列。43、查询和“李军”同性别的所有同学的Sname.44、查询和“李军”同性别并同班的同学Sname.45、查询所有选修“计算机导论”课程的“男”同学的成绩表 部分参考答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511、 查询Student表中的所有记录的Sname、Ssex和Class列。select Sname,Ssex,Class from students2、 查询教师所有的单位即不重复的Depart列。select distinct Depart from teachers 3、 查询Student表的所有记录。select *from students4、 查询Score表中成绩在60到80之间的所有记录。select *from scores where degree&gt;=60 and degree&lt;=805、 查询Score表中成绩为85，86或88的记录。select *from scores where degree=85 or degree=86 or degree=886、 查询Student表中“95031”班或性别为“女”的同学记录。select *from students where class='95031' or ssex='女'7、 以Class降序查询Student表的所有记录。select *from students order by class desc8、 以Cno升序、Degree降序查询Score表的所有记录。select *from scores order by cno asc, degree desc9、 查询“95031”班的学生人数。select count(distinct sno) from students where class='95031'10、查询Score表中的最高分的学生学号和课程号。select sno,cno from scores where degree=(select max(degree) from scores)11、查询'3-105'号课程的平均分。select avg(degree) from scores where cno='3-105'12、查询Score表中至少有5名学生选修的并以3开头的课程的平均分数。select avg(degree) from scores where cno= (select cno from scores group by cno having cno like '3%' and count(*)&gt;5 )13、查询最低分大于70，最高分小于90的Sno列。select sno from scores group by sno having min(degree) &gt;70 and max(degree) &lt;9014、查询所有学生的Sname、Cno和Degree列。select sname,cno,degree from students ,scoreswhere students.sno=scores.sno15、查询所有学生的Sno、Cname和Degree列。select students.sno,cname,degree from students ,courses,scoreswhere students.sno=scores.sno and scores.cno=courses.cno16、查询所有学生的Sname、Cname和Degree列。select Sname,cname,degree from students ,courses,scoreswhere students.sno=scores.sno and scores.cno=courses.cno17、查询“95033”班所选课程的平均分。select avg(degree) from scores where sno in (select sno from students where class='95033')18、假设使用如下命令建立了一个grade表：create table grade(low float(3),upp float(3), rank char(1));insert into grade values(90,100,'A');insert into grade values(80,89,'B');insert into grade values(70,79,'C');insert into grade values(60,69,'D');insert into grade values(0,59,'E');commit;现查询所有同学的Sno、Cno和rank列。select sno,cno,grade.rank from scores,gradewhere degree between low and upp 19、查询选修“3-105”课程的成绩高于“109”号同学成绩的所有同学的记录。select *from students where sno in(select sno from scores where cno='3-105' and degree&gt;(select scores.degree from scores where sno='109' and cno='3-105'))20、查询score中选学一门以上课程的同学中分数为非最高分成绩的记录。select * from scores a where a.degree != (select MAX(degree) from scores b group by sno having COUNT (b.cno)&gt;1 and a.sno=b.sno)select * from scores order by sno 21、查询成绩高于学号为“109”、课程号为“3-105”的成绩的所有记录。select * from scores where cno='3-105' and degree&gt;(select scores.degree from scores where sno='109' and cno='3-105')22、查询和学号为108的同学同年出生的所有学生的Sno、Sname和Sbirthday列。SELECT s1.Sno,s1.Sname,s1.SbirthdayFROM Students AS s1 INNER JOIN Students AS s2ON(YEAR(s1.Sbirthday)=YEAR(s2.Sbirthday))WHERE s2.Sno='108';23、查询“张旭“教师任课的学生成绩。select sno,degree from scores where cno = (select cno from courses where tno =(select tno from teachers where tname='张旭'))24、查询选修某课程的同学人数多于5人的教师姓名。select tname from teachers where tno=(select tno from courses where cno =(select cno from scores group by cno having COUNT(sno)&gt;5))25、查询95033班和95031班全体学生的记录。select * from students where class='95033' or class='95031' order by class desc26、查询存在有85分以上成绩的课程Cno.select cno from scores group by cno having MAX(degree)&gt;8527、查询出“计算机系“教师所教课程的成绩表。select * from scores ,teachers,courses where depart='计算机系' and courses.tno=teachers.tno andscores.cno=courses.cno28、查询“计算机系”与“电子工程系“不同职称的教师的Tname和Prof。select tname,prof from teachers where depart='计算机系' or depart='电子工程系'29、查询选修编号为“3-105“课程且成绩至少高于选修编号为“3-245”的同学的Cno、Sno和Degree,并按Degree从高到低次序排序。select * from scores a where cno='3-105' and sno in(select sno from scores b where cno='3-245' and a.degree&gt;b.degree) order by degree desc30、查询选修编号为“3-105”且成绩高于选修编号为“3-245”课程的同学的Cno、Sno和Degree.31、查询所有教师和同学的name、sex和birthday.select tname as name ,tsex as sex ,tbirthday as birthday from teachers unionselect sname as name ,ssex as sex ,sbirthday as birthday from students32、查询所有“女”教师和“女”同学的name、sex和birthday.select tname as name ,tsex as sex ,tbirthday as birthday from teachers where tsex='女'unionselect sname as name ,ssex as sex ,sbirthday as birthday from students where ssex='女'33、查询成绩比该课程平均成绩低的同学的成绩表。select *from scores a where a.degree &lt;(select AVG(degree) from scores b group by cno having b.cno=a.cno) select AVG(degree)as avg,cno from scores group by cno34、查询所有任课教师的Tname和Depart.select tname,depart from teachers where tno in(select tno from courses)35 查询所有未讲课的教师的Tname和Depart. select tname,depart from teachers where tno not in(select tno from courses)36、查询至少有2名男生的班号。select class from students group by class having COUNT(ssex)&gt;137、查询Student表中不姓“王”的同学记录。select *from students where sname not like '王_'38、查询Student表中每个学生的姓名和年龄。39、查询Student表中最大和最小的Sbirthday日期值。select MAX(sbirthday),MIN(sbirthday) from students 40、以班号和年龄从大到小的顺序查询Student表中的全部记录。select * from students order by class desc ,sbirthday 41、查询“男”教师及其所上的课程。select * from courses,teachers where tsex='男' and teachers.tno=courses.tno42、查询最高分同学的Sno、Cno和Degree列。select * from scores a where a.degree=(select MAX(b.degree) from scores b group by b.cno having a.cno=b.cno)43、查询和“李军”同性别的所有同学的Sname.select sname from students where sname!='李军' and ssex=(select ssex from students where sname='李军')44、查询和“李军”同性别并同班的同学Sname.select a.sname from students a,students b where b.sname='李军' and a.ssex=b.ssex and a.class=b.class45、查询所有选修“计算机导论”课程的“男”同学的成绩表select scores.* from scores,courses,students where cname='计算机导论'and courses.cno=scores.cno and scores.sno =students.sno and students.ssex='男' 参考网址https://blog.csdn.net/mrbcy/article/details/68965271]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在windows使用github创建自己的博客]]></title>
    <url>%2F2018%2F06%2F01%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[目前貌似还没有桌面github的教程，我把我的经验拿出来和大家分享 准备工作 github账号 githubdesk hexo github账号 去github注册账号 直接点击signup 在接下来的页面中创建用户名，填写 email 和设定密码，点击「Create an account」按钮创建账户 选择免费版本 githubdesk创建车库项目 githubdesk下载适合自己版本的，安装打开，登录账号 点击左上角File–&gt;creat a new repository 名字填注册名字，本地地址选择桌面 选择自己的车库，添加概要和描述，以master身份确认，最后点击上传这个时候应该可以从浏览器里登陆https://改成自己的名字.github.io/看到一个空白界面，此时第二步也成功了 hexo安装与使用 安装的话直接看hexo 安装成功后开始菜单里打开Node.js command prompt，进入刚刚创建的文件夹，运行cd命令和dir命令 12345cd desktop hexo init blogcd bolghexo g hexo s 这个时候浏览器输入http://localhost:4000/ 可以看到一个网站博客 在blog里面找到文件夹public,把里面的东西都复制到车库里，然后安装之前的步骤上传就可以了。不过网速会很慢]]></content>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>githubdesk</tag>
      </tags>
  </entry>
</search>
